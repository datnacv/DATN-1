<!DOCTYPE html>
<html lang="vi" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8" />
    <title>X√°c minh khu√¥n m·∫∑t</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f9fafb;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
        }

        .camera-box {
            position: relative;
            width: 300px;
            height: 400px;
            margin-top: 40px;
            border-radius: 16px;
            overflow: hidden;
            background-color: black;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .face-overlay {
            position: absolute;
            top: 60%; /* ‚Üì ƒê∆∞a v√≤ng tr√≤n xu·ªëng gi·ªØa */
            left: 50%;
            width: 180px;
            height: 180px;
            border: 3px solid rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 rgba(34, 197, 94, 0);
            transition: box-shadow 0.25s ease, border-color 0.25s ease;
            z-index: 4;
        }

        .face-overlay.active {
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.8);
            border-color: rgba(34, 197, 94, 0.8);
        }

        .face-progress-ring {
            position: absolute;
            top: 60%; /* ƒë·ªìng b·ªô v·ªã tr√≠ */
            left: 50%;
            width: 200px;
            height: 200px;
            transform: translate(-50%, -50%) rotate(-90deg);
            z-index: 2;
        }

        .face-progress-ring circle {
            fill: none;
            stroke: rgba(34, 197, 94, 0.8);
            stroke-width: 8;
            stroke-dasharray: 565.48;
            stroke-dashoffset: 565.48;
            transition: stroke-dashoffset 0.3s ease;
        }

        .face-ticks {
            position: absolute;
            top: 60%; /* ƒë·ªìng b·ªô v·ªã tr√≠ */
            left: 50%;
            width: 200px;
            height: 200px;
            transform: translate(-50%, -50%) rotate(-90deg);
            z-index: 1;
        }

        .face-ticks line {
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 2;
            transition: stroke 0.3s;
        }

        .face-ticks line.active {
            stroke: rgba(34, 197, 94, 1);
        }

        .status-text {
            margin-top: 20px;
            font-size: 16px;
            color: #374151;
            font-weight: 500;
            text-align: center;
        }

        h2 {
            margin-top: 20px;
            font-size: 20px;
            font-weight: bold;
            color: #111827;
        }
    </style>
</head>
<body th:attr="data-username=${username}">
<h2>X√°c minh khu√¥n m·∫∑t</h2>

<div class="camera-box">
    <video id="video" autoplay muted></video>
    <svg class="face-progress-ring">
        <circle cx="100" cy="100" r="90" id="progressCircle" />
    </svg>
    <svg class="face-ticks" id="tickSvg" viewBox="0 0 200 200"></svg>
    <div class="face-overlay" id="overlay"></div>
</div>

<div class="status-text" id="status">üîÑ ƒêang t·∫£i m√¥ h√¨nh nh·∫≠n di·ªán khu√¥n m·∫∑t...</div>

<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", async () => {
        const video = document.getElementById("video");
        const overlay = document.getElementById("overlay");
        const progressCircle = document.getElementById("progressCircle");
        const statusText = document.getElementById("status");
        const tickSvg = document.getElementById("tickSvg");
        const username = document.body.getAttribute("data-username");

        const totalTicks = 60;
        const tickElements = [];

        function createTicks() {
            const centerX = 100;
            const centerY = 100;
            const radius = 90;
            for (let i = 0; i < totalTicks; i++) {
                const angle = (i / totalTicks) * 2 * Math.PI;
                const x1 = centerX + Math.cos(angle) * (radius - 5);
                const y1 = centerY + Math.sin(angle) * (radius - 5);
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x1);
                line.setAttribute("y1", y1);
                line.setAttribute("x2", x2);
                line.setAttribute("y2", y2);
                tickSvg.appendChild(line);
                tickElements.push(line);
            }
        }

        function updateProgressRing(matches, required) {
            const percent = matches / required;
            const dashArray = 2 * Math.PI * 90;
            progressCircle.style.strokeDashoffset = dashArray * (1 - percent);
        }

        function updateTickProgress(matches, required) {
            const progress = Math.floor((matches / required) * totalTicks);
            tickElements.forEach((line, index) => {
                if (index < progress) {
                    line.classList.add("active");
                } else {
                    line.classList.remove("active");
                }
            });
        }

        createTicks();

        try {
            statusText.textContent = "‚è≥ ƒêang t·∫£i m√¥ h√¨nh...";
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri("/models"),
                faceapi.nets.faceLandmark68Net.loadFromUri("/models"),
                faceapi.nets.faceRecognitionNet.loadFromUri("/models"),
            ]);

            const stream = await navigator.mediaDevices.getUserMedia({ video: {} });
            video.srcObject = stream;
            statusText.textContent = "üëÅÔ∏è ƒêang m·ªü camera...";
        } catch (err) {
            statusText.textContent = "‚ùå Kh√¥ng th·ªÉ m·ªü camera: " + err.message;
            return;
        }

        video.addEventListener("play", async () => {
            try {
                statusText.textContent = "üì° ƒêang truy v·∫•n d·ªØ li·ªáu khu√¥n m·∫∑t...";
                const res = await fetch(`/api/get-descriptor?username=${encodeURIComponent(username)}`);
                const data = await res.json();

                if (!data.descriptors || data.descriptors.length === 0) {
                    throw new Error("Kh√¥ng c√≥ d·ªØ li·ªáu khu√¥n m·∫∑t.");
                }

                const labeledDescriptor = new faceapi.LabeledFaceDescriptors(
                    username,
                    data.descriptors.map(d => new Float32Array(d))
                );
                const matcher = new faceapi.FaceMatcher([labeledDescriptor], 0.45);

                let matches = 0;
                const required = 5;

                const detect = async () => {
                    const detections = await faceapi
                        .detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
                        .withFaceLandmarks()
                        .withFaceDescriptors();

                    if (detections.length === 0) {
                        statusText.textContent = "üò∂ Kh√¥ng ph√°t hi·ªán khu√¥n m·∫∑t.";
                        overlay.classList.remove("active");
                        matches = 0;
                        updateProgressRing(matches, required);
                        updateTickProgress(matches, required);
                        requestAnimationFrame(detect);
                        return;
                    }

                    const result = matcher.findBestMatch(detections[0].descriptor);
                    if (result.label === username && result.distance < 0.45) {
                        matches++;
                        overlay.classList.add("active");
                        statusText.textContent = `‚úÖ ƒê√£ kh·ªõp (${matches}/${required})`;
                        updateProgressRing(matches, required);
                        updateTickProgress(matches, required);
                    } else {
                        matches = 0;
                        overlay.classList.remove("active");
                        updateProgressRing(matches, required);
                        updateTickProgress(matches, required);
                        statusText.textContent = "‚ö†Ô∏è Kh√¥ng kh·ªõp. Vui l√≤ng th·ª≠ l·∫°i.";
                    }

                    if (matches >= required) {
                        statusText.textContent = "üéâ X√°c minh th√†nh c√¥ng! ƒêang chuy·ªÉn h∆∞·ªõng...";
                        await fetch("/acvstore/verify-success", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ username }),
                            credentials: "include"
                        });
                        setTimeout(() => {
                            window.location.href = "/acvstore/thong-ke";
                        }, 1000);
                        return;
                    }

                    requestAnimationFrame(detect);
                };

                detect();
            } catch (err) {
                statusText.textContent = "‚ùå L·ªói x√°c minh: " + err.message;
            }
        });
    });
</script>
</body>
</html>
